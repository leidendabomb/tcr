\documentclass[10pt,hidelinks]{article}

\frenchspacing
\usepackage[a4paper,margin=2cm]{geometry}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{amssymb, amsmath} 
\usepackage{hyperref}
\usepackage{fontspec}
\pagestyle{fancy}
\renewcommand{\headrulewidth}{0.1pt}
\lhead{Universiteit Leiden}
\rhead{\thepage}
\fancyfoot{}
\lstset{
  breakatwhitespace=true,
  breaklines=true,
  tabsize=2,
  basicstyle=\small,
  numbers=left,
  numberstyle=\tiny,
  numberfirstline=false,
  stepnumber=1,
  identifierstyle=\ttfamily
}

\title{Mad hacks\\[1cm]
\small{Team Contest Reference of:}}
\author{{\fontspec{Symbola}ðŸ•´}\\[1cm]
	\small{Universiteit Leiden}}

\begin{document}

\fontsize{10}{12}

\selectlanguage{english}

\maketitle

\newpage

\tableofcontents

\section{Team}
\begin{itemize}
\item Tobias de Jong
\item David Kok
\item Bart van Strien
\end{itemize}

\pagebreak

\section{Confs}

\subsection{vimrc}
\lstinputlisting{conf/vimrc}

\subsection{makefile}
\lstinputlisting[language=make]{conf/Makefile}

\lstset{language=c++}

\subsection{base.cpp}
\lstinputlisting[language=c++]{code/base.cpp}

\pagebreak

\section{STL}

\subsection{Binary search}

\begin{lstlisting}[language=c++]
// True desda element bestaat dat niet groter danwel kleiner is.
bool binary_search(begin, end, x);
\end{lstlisting}

\subsection{Limieten}
In de header \texttt{<limits>} staan de limieten voor de normale datatypes.
\lstinputlisting[language=c++]{code/limits.cpp}

\subsection{Initialisatie}

\lstinputlisting[language=c++]{code/init.cpp}

\pagebreak

\section{Grafen}

\subsection{Doorlopen}

\subsubsection{Depth first}

\lstinputlisting[language=c++]{code/graph-dfs.cpp}

\subsubsection{Breadth first}

\lstinputlisting[language=c++]{code/graph-bfs.cpp}

\subsection{Kortste pad}

\subsubsection{Dijkstra}

Kortste pad van een knoop naar alle andere knopen.

\lstinputlisting[language=c++]{code/dijkstra.cpp}

Eventueel aan te passen door voor iedere knoop zijn voorganger op te slaan. Hierna kunnen de paden bepaald worden.

\subsection{Floyd-Warshall}

Kortste afstand tussen iedere knoop en iedere andere knoop.
\lstinputlisting[language=c++]{code/floydwarshall.cpp}

\section{Priemgetallen}

\subsection{Genereren}

\subsubsection{Zeef van Eratosthenes}

Complexity: $O(n(\text{log }n)(\text{log log }n))$ for $n = \text{\texttt{SIEVE\_MAX}}$.
\lstinputlisting[language=c++]{code/sieve.cpp}

\subsection{Factoriseren}

\subsubsection{Brute force}

\lstinputlisting[language=c++]{code/factorization.cpp}

\subsection{Statische array pregenereren}

\lstinputlisting[language=bash]{code/primegen.sh}

\section{String}

\subsection{Knuth Morris Pratt}

Dit algoritme geeft gegeven een \texttt{needle} en een \texttt{haystack} de eerste positie van \texttt{needle} in \texttt{haystack}, of $-1$ indien het niet gevonden kan worden. Het algoritme is $O(n)$. Het algoritme kan makkelijk aangepast worden om het aantal keer voorkomen van de substring te vinden, of om een aparte matching regel te hebben. Daarnaast kan het nuttig zijn om de fallback tabel te cachen per \texttt{needle}.

\lstinputlisting[language=c++]{code/kmp.cpp}

\section{List of common algorithms}
\begin{itemize}
\item Depth First Search
\item Breadth First Search
\item Binary Search
\item Linear search
\item Dijkstra
\begin{itemize}
\item Bellman-Ford- Dijkstra for negative weights. relax $v-1$ times for all edges
\end{itemize}
\item Ford-Fulkerson: max flow - find paths from source to sink while possible. (breadth- or depth first)
\begin{itemize}
\item Max flow - min cut: FF- then extend from source until no edges with non-zero residual capacity can be added.
\item bipartite matching - find max matches out of a possible set by converting to max flow
\end{itemize}
\item Quicksort $O(n^2)$ - pick pivot, $A<pivot \leq B$, effort splitting
\item Mergesort $O(n \log n)$ - effort merging, compare first of A with first of B
\item Heapsort $O(n \log n)$ - turn array into heap, then repeatedly get the largest value
\item Bubble sort $O(n^2)$- swap neighbours
\item Insertion sort $O(n^2)$
\item Select sort $O(n^2)$ - select minimum in unsorted rest
\item Bucket sort $O(n^2)$ - buckets contain elements with values $a < x \leq b$
\item Radix sort $O(nk)$ - sort numbers by least significant digit (radix $k$), to highest significant digit with stable (typically counting) sort
\item Brute Force
\item Backtracking
\item Divide and Conquer - split and recurse \\
	Depth of Tree
\item Dynamic Programming - fill array bottom up \\
	Fibonacci, knapsack
\item Memoization --- fill array as you go
\item Greedy shit
\item Dijkstra
\item Branch-and-bound - optimization \\
	Cut off when estimate below minimum or above maximum, travelling salesman
\item Transform-and-conquer - transform to known problem, solve that, transform answer
\item Tries
\item Sweep line --- Sort points on one coordinate, walk through them. Binary search possible!
\item Area of polygon --- $\forall (i, j) \in E: \frac12 (x_i+x_j)*(y_i-y_j)$
\end{itemize}

\pagebreak

\section{Pre-coded algorithms}

\subsection{Floodfill}
\lstinputlisting[language=c++]{code/floodfill.cpp}

\subsection{Greatest Common Denominator}
\lstinputlisting[language=c++]{code/gcd.cpp}

\subsubsection{Lowest Common Multiple}
\lstinputlisting[language=c++]{code/lcm.cpp}

\subsection{Building heap}
Insert at the bottom, bubble up by swapping with parent if bigger.

\subsection{Graph diameter}
Set the upper bound to $D_u = \infty$, the lower bound $D_l = -\infty$ and the
list of open nodes $W = V$. The eccentricity of a node is the length of its
longest shortest path.

Until $D_u = D_l$ or $W = \emptyset$.
\begin{itemize}
	\item Select a node $v \in W$.
	\item Compute the eccentricity of $v$. For every node $w$ update the lower
		and upper bounds on the eccentricity, $e_l(w) \leftarrow \max(e_l(w),
		e(v) - d(v, w), d(v, w))$ and $e_u(w) \leftarrow \min(e_u(w), e(v)
		+ d(v, w))$.
	\item Update the diameter bounds $D_l$ and $D_u$.
	\item Remove nodes from $W$ that add no new information.
		$(e_u(w) \leq D_l \land e_l(w) \geq \frac{D_u}{2}) \lor e_l(w) =
		e_u(w)$.
\end{itemize}

A good selection strategy seems to be interchanging the node with the smallest
eccentricity lower bound and the node with the largest eccentricity upper bound.

\section{Math}


\subsection{(co)sinusregel}

\[\frac{\sin a}{\alpha} = \frac{\sin b}{\beta} =\frac{\sin c}{\gamma}\]
\[c^2=a^2+b^2-2ab\cos(\gamma)\]

\subsection{Combinatorics}

\[\binom{n+m}{r} = \sum_{k=0}^r \binom{n}{k} \binom{m}{r-k}\]

\subsection{Recurrency}
The following is a generalization of "Het zal wel een e-macht zijn", corresponding in this discrete case to inserting a trail $\lambda^n$.
For the recurrency relation $a_n = c_1a_{n-1} + c_2a_{n-2} + \dots + c_da_{n-d}$, the characteristic polynomial is given by:
\[p(t) = t^d - \sum_{i=1}^d c_it^{d-i}\]
The solution is given by:
\[a_n = \sum_{i=1}^d k_ir_i^n\]
Where $r_i$ are the roots of the characteristic polynomial and $k_i$ are determined by initial conditions. For roots with multiplicity higher than one the analog of the continuous case also holds (for multiplicity 3):
\[a_n = k_1r^n+k_2nr^n+k_3n^2r^n\]
Dynamical system matrix notation also works.

\subsection{Numeriek benaderen}

\subsubsection{Methode van Newton-Raphson}

De methode van Newton-Raphson berekent gegeven een functie $f(x)$ en zijn afgeleide $f'(x)$ een nulpunt van $f(x)$. Hiervoor is ook een goede schatter $x_0$ nodig. Daarna kun je de volgende iteratiestap toepassen:
\begin{align*}
    x_{n+1} = x_{n} - \frac{f(x_{n})}{f'(x_{n})}
\end{align*}
Deze methode geeft, vanaf het moment dat het eerste cijfer klopt, iedere iteratie ongeveer twee keer zoveel correcte decimalen.

\subsubsection{Ternary search}

Met ternary search kun je van een U-vorminge grafiek een maximum (of minumum) bepalen. De complexiteit van dit algoritme is $\Theta(\log n)$. Het is belangrijk om bij de precisie rekening te houden met de floating point accuracy.

\lstinputlisting[language=c++]{code/ternary_search.cpp}

\subsection{Deelbaarheid}

\subsubsection{3 en 9}

De som van de cijfers moet deelbaar zijn door respectievelijk 3 en 9.

\begin{align*}
	291261 \to & 19 \text{ \emph{niet deelbaar}} \\
	815308974 \to & 45 \text{ \emph{wel deelbaar}}
\end{align*}

\subsubsection{7}

Drie herhaalbare stappen, ge\"illustreerd aan de hand van het voorbeeld 203.

\begin{enumerate}
	\item Neem het laatste cijfer van het oorspronkelijke getal en verdubbel het, in het voorbeeld $3 \to 6$.
	\item Haal dit van het resterende geval, in het voorbeeld $20 - 6 = 14$.
	\item Is het duidelijk dat dit deelbaar is door zeven? Zo niet, ga naar stap 1.
\end{enumerate}

\subsubsection{11}

De alternerende som van de cijfers moet gelijk zijn aan 0. Dit is duidelijker met een voorbeeld.

\[123455216 \to 1 - 2 + 3 - 4 + 5 - 5 + 2 - 1 + 0 = 0\]

\end{document}
